import socket
import re


# Make a soap request to a device/service
def soaprequest(device, service, message):
    # Get the host name and host.
    # TODO: How do I convert from the "normal" event to this url? (Just convert : to /?)
    hostName = 'http://192.168.1.120:49153/upnp/control/basicevent1'
    host = device.baseURL
    port = 49153
    controlURL = service.controlURL

    # Set up the post request header ready to be sent to the controlURL
    soapRequest = 'POST %s HTTP/1.1\r\n' % controlURL
    soapResponse = ''
    MAX_RECV = 8192
    # TODO: Get rid of backslash?
    soapEnd = re.compile('<\/.*:envelope>')

    # TODO: Where do I get this from?
    actionName = 'SetSmartDevInfo'
    serviceType = service.type

    # Create the body of the SOAP request
    soapBody = """<?xml version="1.0" encoding="utf-8"?>
    <s:Envelope xmlns:s="http://schemas.xmlsoap.org/soap/envelope/" s:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">
    <s:Body>
    <u:{0} xmlns:u="{1}">
    {2}
    </u:{0}>
    </s:Body>
    </s:Envelope>
    """.format(actionName, serviceType, message)

    # Create the headers of the SOAP request
    # TODO: should probably give the user the ability to change user agent, especially if devices start hardening
    # Against these kind of scans.
    headers = {
        'Content-Type': 'text/xml; charset="utf-8"',
        'SOAPACTION': '"{0}#{1}"'.format(serviceType, actionName),
        'Content-Length': len(soapBody),
        'HOST': hostName,
        'User-Agent': 'CyberGarage-HTTP/1.0',
    }

    # Print out what we are about to send.
    print(headers)
    print("")
    print(soapBody)

    # For each head and value pair in headers
    for head, value in headers:
        # Add it to the start of the SOAPRequest
        soapRequest += '{0}: {1}\r\n'.format(head, value)
    # After all of the headers have been added in, append the body.
    soapRequest += '\r\n{0}'.format(soapBody)
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        # Set up the sockets so that the connection can be made

        sock.connect((host, port))
        # Send the exploit
        sock.send(soapRequest)
        # Receive the response from the device
        while True:
            data = sock.recv(MAX_RECV)
            if not data:
                break
            else:
                soapResponse += data
                if soapEnd.search(soapResponse.lower()) is not None:
                    break
        sock.close()

        # Split the response into header and body.
        (header, body) = soapResponse.split('\r\n\r\n', 1)

        # If you don't get the expected response, error out.
        if not header.upper().startswith('HTTP/1.1 200'):
            print('SOAP request failed with error code:', header.split('\r\n')[0].split(' ', 1)[1])
            errorMsg = extractSingleTag(body, 'errorDescription')
            if errorMsg:
                print('SOAP error message:', errorMsg)
        else:
            print(body)
    except Exception as e:
        print('Caught socket exception:', e)
        sock.close()
    except KeyboardInterrupt:
        sock.close()


def extractSingleTag(data, tag):
    startTag = "<{0}".format(tag)
    endTag = "</{0}>".format(tag)
    try:
        tmp = data.split(startTag)[1]
        index = tmp.find('>')
        if index != -1:
            index += 1
            return tmp[index:].split(endTag)[0].strip()
    except:
        pass
    return None
